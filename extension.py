# ¿Qué valor agregado tiene el uso de Web Components en su proyecto?
# Complemento:
# El valor más profundo de los Web Components en CotiZen v2 no es simplemente "organizar el código", sino crear una barrera de aislamiento real entre partes del sistema que no deberían conocerse entre sí.
# En un formulario tradicional sin componentes, agregar cinco servicios a una cotización significaría tener cinco bloques de HTML casi idénticos en el documento, con IDs como precio-1, precio-2, descripcion-3, y lógica JavaScript llena de bucles que buscan esos IDs por convención. Si alguien cambia el nombre de un campo, todo se rompe. Si se quiere agregar un sexto servicio dinámicamente, hay que duplicar manualmente la estructura.
# Con <service-row>, eso desaparece. Cada fila es una caja negra que sabe cómo dibujarse, validarse y comunicar su eliminación. La lógica principal no necesita saber qué hay dentro; solo necesita saber si es válida y qué datos contiene.
# Lo mismo aplica para <quote-card>: en lugar de construir el HTML de la tarjeta con concatenación de strings (práctica propensa a errores y vulnerabilidades XSS), se crea un elemento con datos y él se encarga de renderizarse correctamente.
# ¿Por qué esto importa a largo plazo? Porque cuando el proyecto crezca y alguien necesite cambiar el diseño de la tarjeta de cotización, solo tocará el interior del componente. El resto del sistema no sabrá ni que algo cambió.

# ¿De qué forma manipularon los datos sin recargar la página?
# Complemento:
# El punto central aquí es que el navegador, por diseño, quiere enviar formularios al servidor y recargar. Toda la arquitectura de CotiZen v2 trabaja en contra de ese comportamiento por defecto, y lo hace de forma completamente deliberada.
# preventDefault() es la línea más importante del proyecto. Sin ella, en el momento en que el usuario hace clic en "Generar", el navegador enviaría los datos a ninguna parte (o al mismo URL), la página se recargaría, y todo el estado en memoria —historial, cotizaciones, filas de servicio— desaparecería en un instante.
# La creación dinámica de elementos con createElement() tiene una ventaja adicional que vale la pena destacar: es más segura que usar innerHTML. Cuando se construye HTML concatenando strings (innerHTML = '<div>' + userInput + '</div>'), un usuario malicioso podría inyectar código JavaScript dentro de ese string. Al crear elementos programáticamente y asignar valores con .textContent o atributos directos, ese vector de ataque se elimina por completo.
# El manejo del arreglo history como estado de la aplicación es también un patrón arquitectónico importante: en lugar de volver a leer el DOM cada vez que se necesita información de cotizaciones anteriores (lo cual es lento y frágil), se mantiene una representación de los datos en memoria que siempre está sincronizada con lo que se muestra en pantalla.

# ¿De qué forma validaron las entradas de datos?
# Complemento:
# La decisión más relevante en el sistema de validación de CotiZen v2 es que la validación no ocurre solo al intentar enviar el formulario. Ocurre continuamente, mientras el usuario escribe.
# Esto marca una diferencia enorme en la experiencia: el usuario no llena todo el formulario, hace clic en "Generar" y entonces descubre que olvidó cinco campos. En cambio, el error aparece en el momento exacto en que el campo pierde el foco o cuando el usuario corrige su contenido, y desaparece inmediatamente cuando el valor ya es válido. Esto se llama validación reactiva y es el estándar de usabilidad en aplicaciones modernas.
# El diseño de dos niveles tiene además una ventaja técnica: la validación de <service-row> está encapsulada dentro del componente, no en el formulario principal. Esto significa que si mañana se agrega un nuevo tipo de fila (por ejemplo, <discount-row>), ese componente trae su propia lógica de validación consigo. El formulario principal no necesita actualizarse para saber cómo validarlo; simplemente llama a su método validate() y confía en el resultado.
# La verificación de .trim() antes de comparar con cadena vacía es también una decisión deliberada: un campo que contiene solo espacios en blanco visualmente parece lleno, pero semánticamente está vacío. Sin .trim(), ese caso pasaría la validación incorrectamente.
# El uso de parseFloat() combinado con !isNaN() para precios cubre tres casos que una simple comparación numérica no cubre: el campo vacío, el campo con texto no numérico y el valor NaN que resulta de entradas como "12abc".

# ¿Cómo manejaría la escalabilidad futura en su página?
# Complemento:
# La escalabilidad no es solo una lista de features que se pueden agregar; es la consecuencia de decisiones tomadas hoy que hacen que agregar esas features mañana sea barato en tiempo y en riesgo.
# En CotiZen v2, la decisión más importante para la escalabilidad ya está tomada: los componentes no dependen del formulario y el formulario no depende del interior de los componentes. Esa independencia es exactamente lo que permite que el sistema crezca sin que agregar algo nuevo rompa algo existente.
# Por ejemplo, agregar persistencia con localStorage no requeriría tocar ni los Web Components ni el sistema de validación. Solo se modificaría la función que hoy guarda en el arreglo history, para que también llame a localStorage.setItem(). El resto del sistema no sabría que algo cambió.
# La migración a un backend con API REST seguiría el mismo principio: se añadiría una capa de fetch() entre la lógica de generación de cotizaciones y el servidor. Los componentes no cambiarían. La validación no cambiaría. Solo se agregaría una nueva responsabilidad (comunicación con el servidor) sin modificar las existentes.
# Respecto a migrar a un framework como React o Vue: los Web Components son el único tipo de componente que todos los frameworks aceptan de forma nativa. Un componente <service-row> escrito con la API estándar puede usarse dentro de un componente React, dentro de un template de Vue, o en un proyecto Svelte, sin modificar una sola línea de su código interno. Esto hace que la inversión en desarrollar buenos Web Components tenga un retorno a largo plazo muy superior al de construir componentes atados a un framework específico.